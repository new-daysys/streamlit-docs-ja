---
title: Advanced concepts of Streamlit
slug: /get-started/fundamentals/advanced-concepts
---

# 少し高度な概念

Streamlit アプリがどのように実行され、どのようにデータが処理されるかがわかったところで、効率について話しましょう。キャッシュを使用すると、関数の出力を保存できるため、再実行時にスキップできます。セッション状態を使用すると、各ユーザーの情報を保存し、再実行の間に保存できます。これにより、不必要な再計算を回避できるだけでなく、動的なページを作成して段階的なプロセスを処理することもできます。

## キャッシュ

キャッシュを使用すると、Web からデータを読み込んだり、大規模なデータセットを操作したり、高価な計算を実行したりする場合でも、アプリのパフォーマンスを維持できます。

キャッシュの基本的な考え方は、負荷の高い関数呼び出しの結果を保存し、同じ入力が再び発生したときにキャッシュされた結果を返すというものです。これにより、同じ入力値を使用した関数の繰り返し実行が回避されます。

Streamlit で関数をキャッシュするには、関数にキャッシュデコレーターを適用する必要があります。選択肢は 2 つあります。

- `st.cache_data` は、データを返す計算をキャッシュするための推奨される方法です。シリアル化可能なデータ オブジェクト (str、int、float、DataFrame、dict、list など) を返す関数を使用する場合は、`st.cache_data` を使用します。 **関数呼び出しごとにデータの新しいコピーが作成されます**。これにより、[突然変異と競合状態](/develop/concepts/architecture/caching#mutation-and-concurrency-issues) に対して安全になります。ほとんどの場合、`st.cache_data` の動作はあなたが望むものです。そのため、よくわからない場合は、`st.cache_data` から始めて、それが機能するかどうかを確認してください。
- `st.cache_resource` は、ML モデルやデータベース接続などのグローバル リソースをキャッシュするための推奨される方法です。関数が複数回ロードしたくないシリアル化できないオブジェクトを返す場合は、`st.cache_resource` を使用します。 **キャッシュされたオブジェクト自体を返します**。これは、コピーや複製を行わずにすべての再実行とセッションで共有されます。 `st.cache_resource` を使用してキャッシュされたオブジェクトを変更すると、その変更はすべての再実行とセッションにわたって存在します。

Example:

```python
@st.cache_data
def long_running_function(param1, param2):
    return …
```

上記の例では、`long_running_function` が `@st.cache_data` で修飾されています。その結果、Streamlit は以下を記録します。

- 関数の名前 (`"long_running_function"`)
- 入力の値 (`param1`、`param2`)
- 関数内のコード

`long_running_function` 内のコードを実行する前に、Streamlit はキャッシュに以前に保存された結果がないかチェックします。指定された関数と入力値のキャッシュされた結果が見つかった場合、そのキャッシュされた結果が返され、関数のコードは再実行されません。それ以外の場合、Streamlit は関数を実行し、結果をキャッシュに保存し、スクリプトの実行を続行します。開発中、関数コードが変更されるとキャッシュが自動的に更新され、最新の変更がキャッシュに確実に反映されます。

Streamlit キャッシュ デコレーター、その構成パラメーター、およびその制限の詳細については、[キャッシュ](/develop/concepts/architecture/caching)を参照してください。

## セッション状態

セッション状態は、スクリプトの再実行の間に保持される情報を保存できる辞書のようなインターフェイスを提供します。値を保存したり呼び出したりするには、キーまたは属性の表記とともに `st.session_state` を使用します。たとえば、`st.session_state["my_key"]` または `st.session_state.my_key` です。ウィジェットはステートフル性をすべて単独で処理するため、必ずしもセッション状態を使用する必要はないことに注意してください。

### セッションとは何ですか?

セッションは、アプリを表示する単一のインスタンスです。ブラウザーの 2 つの異なるタブからアプリを表示する場合、各タブには独自のセッションが存在します。したがって、アプリの各ビューアは、特定のビューに関連付けられたセッション状態を持ちます。 Streamlit は、ユーザーがアプリを操作している間、このセッションを維持します。ユーザーがブラウザ ページを更新するか、アプリに URL をリロードすると、セッション状態がリセットされ、新しいセッションが再び開始されます。

### セッション状態の使用例

これは、ページが実行された回数をカウントする単純なアプリです。ボタンをクリックするたびに、スクリプトが再実行されます。

```python
import streamlit as st

if "counter" not in st.session_state:
    st.session_state.counter = 0

st.session_state.counter += 1

st.header(f"This page has run {st.session_state.counter} times.")
st.button("Run it again")
```

- **初回実行:** 各ユーザーに対して初めてア​​プリを実行するとき、セッション状態は空です。したがって、キーと値のペアが作成されます (`"counter":0`)。スクリプトが続行すると、カウンタはすぐにインクリメントされ (`"counter":1`)、「このページは 1 回実行されました。」という結果が表示されます。ページが完全にレンダリングされると、スクリプトは終了し、Streamlit サーバーはユーザーが何らかの操作を行うのを待ちます。そのユーザーがボタンをクリックすると、再実行が開始されます。

- **2 回目の実行:** `counter` はすでにセッション状態のキーであるため、再初期化されません。スクリプトが続行されると、カウンタがインクリメントされ (`"counter":2`)、「このページは 2 回実行されました。」という結果が表示されます。

セッション状態が役立つ一般的なシナリオがいくつかあります。上で示したように、セッション状態は、ある再実行から次の再実行に基づいて構築する漸進的なプロセスがある場合に使用されます。セッション状態は、キャッシュと同様に、再計算を防ぐために使用することもできます。ただし、相違点は重要です。

- キャッシュは、保存された値を特定の関数および入力に関連付けます。キャッシュされた値は、すべてのセッションにわたってすべてのユーザーがアクセスできます。
- セッション状態は、保存された値をキー (文字列) に関連付けます。セッション状態の値は、それが保存された単一セッションでのみ使用できます。

アプリで乱数を生成する場合は、セッション状態を使用する可能性があります。以下は、各セッションの開始時にデータがランダムに生成される例です。このランダムな情報をセッション状態に保存すると、各ユーザーがアプリを開いたときに異なるランダム データを取得しますが、アプリを操作するときにデータが変化し続けることはありません。ピッカーで別の色を選択すると、再実行のたびにデータが再ランダム化されないことがわかります。 (新しいタブでアプリを開いて新しいセッションを開始すると、異なるデータが表示されます。)

```python
import streamlit as st
import pandas as pd
import numpy as np

if "df" not in st.session_state:
    st.session_state.df = pd.DataFrame(np.random.randn(20, 2), columns=["x", "y"])

st.header("Choose a datapoint color")
color = st.color_picker("Color", "#FF0000")
st.divider()
st.scatter_chart(st.session_state.df, x="x", y="y", color=color)
```

すべてのユーザーに対して同じデータを取得する場合は、そのデータを取得する関数をキャッシュする可能性があります。一方、個人情報のクエリなど、ユーザーに固有のデータを取得する場合は、それをセッション状態に保存することができます。こうすることで、クエリされたデータはその 1 つのセッションでのみ利用可能になります。

[基本概念](/get-started/fundamentals/main-concepts#widgets) で説明したように、セッション状態はウィジェットにも関連しています。ウィジェットは魔法のようで、ステートフル性を単独で静かに処理します。ただし、高度な機能として、ウィジェットにキーを割り当てることで、コード内のウィジェットの値を操作できます。ウィジェットに割り当てられたキーは、ウィジェットの値に関連付けられたセッション状態のキーになります。これを使用してウィジェットを操作できます。 Streamlit の基本を理解したら、興味があれば [ウィジェットの動作](/develop/concepts/architecture/widget-behavior) に関するガイドを参照して詳細を調べてください。

## データベース接続する

上でヒントしたように、`@st.cache_resource` を使用してデータベース接続をキャッシュできます。これは最も一般的なソリューションであり、任意の Python ライブラリからのほぼすべての接続を使用できます。ただし、Streamlit は、SQL などの最も一般的な接続を処理する便利な方法も提供します。 `st.connection` がキャッシュを処理してくれるので、コード行を減らすことができます。データベースからデータを取得するのは次のように簡単です。

```python
import streamlit as st

conn = st.connection("my_database")
df = conn.query("select * from my_table")
st.dataframe(df)
```

もちろん、ユーザー名とパスワードがどこに行くのか疑問に思うかもしれません。 Streamlit には、[シークレット管理](/develop/concepts/connections/secrets-management) のための便利なメカニズムがあります。ここでは、`st.connection` がシークレットに対してどのようにうまく機能するかを見てみましょう。ローカルのプロジェクトディレクトリに、`.streamlit/secrets.toml` ファイルを保存できます。シークレットを toml ファイルに保存すると、`st.connection` はそれを使用するだけです。たとえば、アプリファイル `streamlit_app.py` がある場合、プロジェクト ディレクトリは次のようになります。

```bash
your-LOCAL-repository/
├── .streamlit/
│   └── secrets.toml # Make sure to gitignore this!
└── streamlit_app.py
```

上記の SQL 例の場合、`secrets.toml` ファイルは次のようになります。

```toml
[connections.my_database]
    type="sql"
    dialect="mysql"
    username="xxx"
    password="xxx"
    host="example.com" # IP or URL
    port=3306 # Port number
    database="mydb" # Database name
```

`secrets.toml` ファイルをリポジトリにコミットしたくないため、アプリを公開する準備ができたら、ホストがシークレットを処理する方法を学ぶ必要があります。ホストプラットフォームごとに、シークレットを渡す方法が異なる場合があります。たとえば、Streamlit Community Cloud を使用する場合、デプロイされた各アプリには、シークレットをロードできる設定メニューがあります。アプリを作成し、デプロイする準備ができたら、Community Cloud で [アプリをデプロイ](/deploy/streamlit-community-cloud/deploy-your-app) する方法をすべて読むことができます。

